<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.MSBuild.Logger</name>
    </assembly>
    <members>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:JetBrains.MSBuild.Logger.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with
            <see cref="T:JetBrains.MSBuild.Logger.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
              <item>FDT      ::= FDTRow [;FDTRow]*</item>
              <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
              <item>Input    ::= ParameterName: Value [, Input]*</item>
              <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
              <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br />
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br />
            <c>canbenull</c> annotation is only applicable for output parameters.<br />
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br />
            </syntax>
            <examples><list>
              <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
              <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
              <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
              <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
              <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ImplicitNotNullAttribute">
            <summary>
            Implicitly apply [NotNull]/[ItemNotNull] annotation to all the of type members and parameters
            in particular scope where this annotation is used (type declaration or whole assembly).
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.MSBuild.Logger.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.MSBuild.Logger.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ItemNotNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:JetBrains.MSBuild.Logger.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>
            >
        </member>
        <member name="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:JetBrains.MSBuild.Logger.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:JetBrains.MSBuild.Logger.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:JetBrains.MSBuild.Logger.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:JetBrains.MSBuild.Logger.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.NotifyPropertyChangedInvocatorAttribute">
            <summary>
             Indicates that the method is contained in a type that implements
            <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
            </summary>
            <remarks>
             The method should be non-static and conform to one of the supported signatures:
            <list>
              <item><c>NotifyChanged(string)</c></item>
              <item><c>NotifyChanged(params string[])</c></item>
              <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
              <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
              <item><c>SetProperty{T}(ref T, T, string)</c></item>
            </list>
            </remarks>
            <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
            Examples of generated notifications:
            <list>
              <item><c>NotifyChanged("Property")</c></item>
              <item><c>NotifyChanged(() =&gt; Property)</c></item>
              <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
              <item><c>SetProperty(ref myField, value, "Property")</c></item>
            </list>
            </example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:JetBrains.MSBuild.Logger.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:JetBrains.MSBuild.Logger.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Api.IJetMsbuildLogger">
            <summary>
            Entry point interface for all the services of this DLL.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Api.IJetMsbuildLogger.CreateSession(JetBrains.MSBuild.Logger.Api.IErrorReportService)">
            <summary>
            Create a new session each time you are about to run MSBuild.exe. The session would give you the command line customizations for MSBuild.exe and means for getting its events.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Api.ILoggerSession.Close">
            <summary>
            Close when done to release the session resources.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Api.ILoggerSession.MakeMsbuildCommandLineParameterForLogger(System.Boolean)">
            <summary>
            Gets the whole command line parameter (key+value) for either the <c>/logger</c> or <c>/distributedlogger:</c> key, based on this library considerations, to be used when starting MSBuild so that it loaded this logger and made possible sinking its messages.
            </summary>
            <param name="isVerbose"></param>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Api.ILoggerSession.SetMessageSink(JetBrains.MSBuild.Logger.Api.ILoggerMessageSink)">
            <summary>
            Logger messages received from the logger instance within MSBuild.exe will be submitted to this sink.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Api.JetMsbuildLogger">
            <summary>
            The entry point instance to be created by the consumer.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Api.LoggerMessageKind.ProjectFinished">
            <summary>
            Special status record.
            Used for tracking progress.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Api.LoggerMessageKind.ProjectStarted">
            <summary>
            Special status record.
            Used to enable lookup of a project file by its ID — establishes the mapping.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.AccessRights">
            <remarks>
              <code>
             3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
             1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
            +---------------+---------------+-------------------------------+
            |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
            |R|W|E|A|     |S|               |                               |
            +-+-------------+---------------+-------------------------------+
            </code>
            </remarks>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.DUPLICATE.DUPLICATE_CLOSE_SOURCE">
            <summary>
            Closes the source handle. This occurs regardless of any error status returned.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.DUPLICATE.DUPLICATE_SAME_ACCESS">
            <summary>
            Ignores the dwDesiredAccess parameter. The duplicate handle has the same access as the source.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.CREATE_ALWAYS">
            <summary>
             Creates a new file, always.
            If the specified file exists and is writable, the function overwrites the file, the function succeeds, and last-error code is set to ERROR_ALREADY_EXISTS (183).
            If the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero.
            For more information, see the Remarks section of this topic.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.CREATE_NEW">
            <summary>
             Creates a new file, only if it does not already exist.
            If the specified file exists, the function fails and the last-error code is set to ERROR_FILE_EXISTS (80).
            If the specified file does not exist and is a valid path to a writable location, a new file is created.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.OPEN_ALWAYS">
            <summary>
             Opens a file, always.
            If the specified file exists, the function succeeds and the last-error code is set to ERROR_ALREADY_EXISTS (183).
            If the specified file does not exist and is a valid path to a writable location, the function creates a file and the last-error code is set to zero.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.OPEN_EXISTING">
            <summary>
             Opens a file or device, only if it exists.
            If the specified file or device does not exist, the function fails and the last-error code is set to ERROR_FILE_NOT_FOUND (2).
            For more information about devices, see the Remarks section.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.TRUNCATE_EXISTING">
            <summary>
             Opens a file and truncates it so that its size is zero bytes, only if it exists.
            If the specified file does not exist, the function fails and the last-error code is set to ERROR_FILE_NOT_FOUND (2).
            The calling process must open the file with the GENERIC_WRITE bit set as part of the dwDesiredAccess parameter.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.IoControlCodes">
            <summary>
            The following is a list of the native file system fsctls followed by additional network file system fsctls.  Some values have been decommissioned.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.IoControlCodes.CTL_CODE(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Macro definition for defining IOCTL and FSCTL function control codes.  Note
            that function codes 0-2047 are reserved for Microsoft Corporation, and
            2048-4095 are reserved for customers.
            </summary>
            <param name="DeviceType"></param>
            <param name="Function"></param>
            <param name="Method"></param>
            <param name="Access"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel">
            <summary>
            Pumps messages over a pipe between appdomains or processes.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.IPipeMessageChannel">
            <summary>
            Common interface for <see cref="T:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel"/> and its fallbacks.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.IPipeMessageChannel.CreateReader(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.Action{System.Byte[],System.UInt32,System.UInt32},JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Defines the channel name, opens the reader, returns the token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely.
            </summary>
            <param name="lifetime">Closes the channel and drops unread messages.</param>
            <param name="FOnRead">Callback on every message. The buffer is reusable, do not store it.</param>
            <param name="logger"></param>
            <returns>The token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely; and the channel name to be passed to the writer.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.IPipeMessageChannel.CreateWriter``1(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.String,JetBrains.MSBuild.Logger.Channels.ChannelWriter{``0}.ItemSerializer,JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Opens the writing end of the pipe; it's the client, so the server (reader) end must be opened already.
            </summary>
            <typeparam name="TItem">Item type, for the serializer. Serialization is taken out async, so the implementation needs the serializer to run.</typeparam>
            <param name="lifetime">Enforces writing out all remaining items and close the channel.</param>
            <param name="sChannelName">The channel name given in the <see cref="T:JetBrains.MSBuild.Logger.Channels.ChannelReader"/> struct obtained when opening the reader end.</param>
            <param name="serializer">Per-item serializer.</param>
            <param name="logger"></param>
            <returns>A token which has the write function.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.#ctor">
            <summary>
            Use the <see cref="F:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.Factory"/> instance.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.JetBrains#MSBuild#Logger#Channels#IPipeMessageChannel#CreateReader(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.Action{System.Byte[],System.UInt32,System.UInt32},JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Defines the channel name, opens the reader, returns the token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely.
            </summary>
            <param name="lifetime">Closes the channel and drops unread messages.</param>
            <param name="FOnRead">Callback on every message. The buffer is reusable, do not store it.</param>
            <param name="logger"></param>
            <returns>The token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely; and the channel name to be passed to the writer.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.JetBrains#MSBuild#Logger#Channels#IPipeMessageChannel#CreateWriter``1(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.String,JetBrains.MSBuild.Logger.Channels.ChannelWriter{``0}.ItemSerializer,JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Opens the writing end of the pipe; it's the client, so the server (reader) end must be opened already.
            </summary>
            <typeparam name="TItem">Item type, for the serializer. Serialization is taken out async, so the implementation needs the serializer to run.</typeparam>
            <param name="lifetime">Enforces writing out all remaining items and close the channel.</param>
            <param name="sChannelName">The channel name given in the <see cref="T:JetBrains.MSBuild.Logger.Channels.ChannelReader"/> struct obtained when opening the reader end.</param>
            <param name="serializer">Per-item serializer.</param>
            <param name="logger"></param>
            <returns>A token which has the write function.</returns>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle">
            <summary>
            An async wait handle which is somewhat like the manual-reset wait handle.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle.ResetAndWaitAsync">
            <summary>
            Resets the state.
            Awaits for someone to call <see cref="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle.Set"/>.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle.Set">
            <summary>
            Sets the event in the signaled state. Whoever is waiting on <see cref="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle.ResetAndWaitAsync"/>, would wake up.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1">
            <summary>
            An async wait handle which is somewhat like the manual-reset wait handle.
            NOTE(H): this version tends to execute the payload SYNC on the calling thread when doing SetResult, and looks like there are no easy ways to overcome that. And occupying the calling thread is no-no for us.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1.myTasker">
            <summary>
            When in non-signaled state, holds the current awaitable.
            To signal, the source is replaced with NULL and set as complete.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1.ResetAndWaitAsync">
            <summary>
            Resets the state.
            Awaits for someone to call <see cref="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1.Set"/>.
            Note that unlike the system event handles ALL the waiters would be awakened when set, not just the first one.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1.Set">
            <summary>
            Sets the event in the signaled state. Whoever is waiting on <see cref="M:JetBrains.MSBuild.Logger.Infra.Util.NamedPipeNativeMessageChannel.ManualResetAwaitHandle1.ResetAndWaitAsync"/>, would wake up.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.PIPE_ACCESS.PIPE_ACCESS_DUPLEX">
            <summary>
            The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of GENERIC_READ and GENERIC_WRITE access to the pipe. The client can specify GENERIC_READ or GENERIC_WRITE, or both, when it connects to the pipe using the CreateFile function.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.PIPE_ACCESS.PIPE_ACCESS_INBOUND">
            <summary>
            The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of GENERIC_READ access to the pipe. The client must specify GENERIC_WRITE access when connecting to the pipe. If the client must read pipe settings by calling the GetNamedPipeInfo or GetNamedPipeHandleState functions, the client must specify GENERIC_WRITE and FILE_READ_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.PIPE_ACCESS.PIPE_ACCESS_OUTBOUND">
            <summary>
            The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of GENERIC_WRITE access to the pipe. The client must specify GENERIC_READ access when connecting to the pipe. If the client must change pipe settings by calling the SetNamedPipeHandleState function, the client must specify GENERIC_READ and FILE_WRITE_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.PIPE_TYPE.PIPE_TYPE_BYTE">
            <summary>
            Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.PIPE_TYPE.PIPE_TYPE_MESSAGE">
            <summary>
            Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The GetLastError function returns ERROR_MORE_DATA when a message is not read completely. This mode can be used with either PIPE_READMODE_MESSAGE or PIPE_READMODE_BYTE.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags">
            <summary>
            Flags off the <see cref="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.RegisterWaitForSingleObject(System.Void**,System.Void*,System.Void*,System.Void*,System.UInt32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_EXECUTEDEFAULT">
            <summary>
            By default, the callback function is queued to a non-I/O worker thread.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_EXECUTEINIOTHREAD">
            <summary>
             This flag is not used.
            Windows Server 2003 and Windows XP:  The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state. I/O worker threads were removed starting with Windows Vista and Windows Server 2008.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_EXECUTEINPERSISTENTTHREAD">
            <summary>
             The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other wait operations. This flag must be set if the thread calls functions that use APCs. For more information, see Asynchronous Procedure Calls.
            Note that currently no worker thread is truly persistent, although no worker thread will terminate if there are any pending I/O requests.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_EXECUTEINWAITTHREAD">
            <summary>
             The callback function is invoked by the wait thread itself. This flag should be used only for short tasks or it could affect other wait operations.
            Deadlocks can occur if some other thread acquires an exclusive lock and calls the UnregisterWait or UnregisterWaitEx function while the callback function is trying to acquire the same lock.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_EXECUTEONLYONCE">
            <summary>
            The thread will no longer wait on the handle after the callback function has been called once. Otherwise, the timer is reset every time the wait operation completes until the wait operation is canceled.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags.WT_TRANSFER_IMPERSONATION">
            <summary>
             Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token.
            Windows XP:  This flag is not supported until Windows XP with SP2 and Windows Server 2003.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.WAITORTIMERCALLBACK">
            <summary>
            An application-defined function that serves as the starting address for a timer callback or a registered wait callback. Specify this address when calling the CreateTimerQueueTimer, RegisterWaitForSingleObject function.
            </summary>
            <param name="lpParameter"></param>
            <param name="TimerOrWaitFired"></param>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.WinDef.INFINITE">
            <summary>
            Infinite timeout.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.FATAL">
            <summary>
            For errors that are
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debbuging
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader">
            <summary>
            Reads from the reader end of the pipe which has been opened with Overlapped IO enabled.
            The read is asynchronous without holding up any threads, using OS ThreadpoolIO.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.myIsBusy">
            <summary>
            Either placing a read async call, or analyzing its results and whether it's sync or async, or running the code inside the callback.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.myIsInCallback">
            <summary>
            Set to True when executing callback code. Most importantly, we must not wait for a callback when inside a callback. Changed under the <see cref="F:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.myIsBusy"/> lock only, allows to tell if we're taking the lock in some nested code of the callback.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.myIsPendingRead">
            <summary>
            Set to TRUE when we issue a read request and until either take it sync or get the async callback. These two check whoever is the first one by checking this flag.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.myIsReadChainStopped">
            <summary>
            Not processing or awaiting, usually because the lifetime has been terminated or pipe broken or some error has occured.
            Means there's no pending wait, we're not analyzing the pending read results, and we're not about to do a new pending read.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.#ctor(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.Void*,System.Action{JetBrains.MSBuild.Logger.Infra.Util.ByteBuffer},System.Action)">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="FOnRead">Reader callback. Must not do complex operations, as might occur on the OS IO pool thread and under a lock. The buffer is temporary for the callback duration only. MUST NOT terminate lifetime in it.</param>
            <param name="FUserOnEof">Optional. Notifies when reading the pipe breaks. Same callback limitations apply: OS thread, under lock. MUST NOT terminate lifetime in it.</param>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.WaitCallbackConnectNamedPipe(System.Void*,System.Byte)">
            <summary>
            Callback on completed waiting for clients to connect to the pipe, so that we could start reading from it
            </summary>
            <param name="lpparameter"></param>
            <param name="timerorwaitfired"></param>
        </member>
        <member name="P:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.IsRunning">
            <summary>
            Gets whether the lifetime has not yet been terminated and the pipe has not yet been closed on either end.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.AsyncPipeReader.NativeWaitHandle">
            <summary>
            Allows to guise a native HANDLE as a netfx waitable handle.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FILE_SKIP.FILE_SKIP_COMPLETION_PORT_ON_SUCCESS">
            <summary>
             If the following three conditions are true, the I/O Manager does not queue a completion entry to the port, when it would ordinarily do so. The conditions are:
            •A completion port is associated with the file handle.
            •The file is opened for asynchronous I/O.
            •A request returns success immediately without returning ERROR_PENDING.
            When the FileHandle parameter is a socket, this mode is only compatible with Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a non-IFS LSP is installed, use the WSAEnumProtocols function and examine the dwServiceFlag1 member in each returned WSAPROTOCOL_INFO structure. If the XP1_IFS_HANDLES (0x20000) bit is cleared then the specified LSP is not an IFS LSP. Vendors that have non-IFS LSPs are encouraged to migrate to the Windows Filtering Platform (WFP).
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.FILE_SKIP.FILE_SKIP_SET_EVENT_ON_HANDLE">
            <summary>
             The I/O Manager does not set the event for the file object if a request returns with a success code, or the error returned is ERROR_PENDING and the function that is called is not a synchronous function.
            If an explicit event is provided for the request, it is still signaled.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.IoCompletionCallback">
            <summary>
            Hook delegate for the  function.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.NativeThunksForDelegates">
            <summary>
              <para>Pins managed delegates for which native thunks have been created to make them gc-reachable and prevent from being deallocated while they are still in use.</para>
              <para>Why just storing a reference with a controlling lifetime might not be enough? (1) We want to keep the thunk a bit longer than the stuff we want to tear down when the callback occurs, to make sure execution has enough time to exit the thunk. (2) Lifetime teardown might be the only scheduled activity for the thunk, and the lifetime might not have a parent lifetime, in which case delegate and lifetime form an isolated cycle and are not reachable for GC, and might be all collected prematurely, so we need a static root for this cycle.</para>
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.NativeThunksForDelegates.DelegateComparer">
            <summary>
            Compares delegates by references, for us
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.OVERLAPPED.PointerOrOffset">
            <summary>
            NOTE(H): this is a union of two DWORDS and a pointer, so it would always be at least a QWORD, hope pointers never get above 64bit.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.CancelIoEx(System.Void*,JetBrains.MSBuild.Logger.Infra.Util.OVERLAPPED*)">
            <summary>
            Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile"></param>
            <param name="lpOverlapped"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.CloseHandle(System.Void*)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. If the application is running under a debugger, the function will throw an exception if it receives either a handle value that is not valid or a pseudo-handle value. This can happen if you close a handle twice, or if you call CloseHandle on a handle returned by the FindFirstFile function.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.ConnectNamedPipe(System.Void*,JetBrains.MSBuild.Logger.Infra.Util.OVERLAPPED*)">
            <summary>
            Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A client process connects by calling either the CreateFile or CallNamedPipe function.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.CreateEventW(JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES*,System.Int32,System.Int32,System.Char*)">
            <summary>
             Creates or opens a named or unnamed event object.
            To specify an access mask for the object, use the CreateEventEx function.
            </summary>
            <param name="lpEventAttributes">A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The lpSecurityDescriptor member of the structure specifies a security descriptor for the new event. If lpEventAttributes is NULL, the event gets a default security descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token of the creator.
            </param>
            <param name="bManualReset">If this parameter is TRUE, the function creates a manual-reset event object, which requires the use of the ResetEvent function to set the event state to nonsignaled. If this parameter is FALSE, the function creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single waiting thread has been released. </param>
            <param name="bInitialState">If this parameter is TRUE, the initial state of the event object is signaled; otherwise, it is nonsignaled. </param>
            <param name="lpName">The name of the event object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named event object, this function requests the EVENT_ALL_ACCESS access right. In this case, the bManualReset and bInitialState parameters are ignored because they have already been set by the creating process. If the lpEventAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the event object is created without a name.
            If lpName matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the function call, the function returns a handle to the existing object and GetLastError returns ERROR_ALREADY_EXISTS.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.CreateFileW(System.String,System.UInt32,System.UInt32,JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES*,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            The CreateFile function creates or opens a file, file stream, directory, physical disk, volume, console buffer, tape drive,
            communications resource, mailslot, or named pipe. The function returns a handle that can be used to access an object.
            </summary>
            <param name="lpFileName"></param>
            <param name="dwDesiredAccess"> access to the object, which can be read, write, or both</param>
            <param name="dwShareMode">The sharing mode of an object, which can be read, write, both, or none</param>
            <param name="lpSecurityAttributes">A pointer to a SECURITY_ATTRIBUTES structure that determines whether or not the returned handle can
            be inherited by child processes. Can be null</param>
            <param name="dwCreationDisposition">An action to take on a file or device that exists or does not exist. For devices other than files, this parameter is usually set to <see cref="F:JetBrains.MSBuild.Logger.Infra.Util.FileCreationDisposition.OPEN_EXISTING"/>.</param>
            <param name="dwFlagsAndAttributes">The file attributes and flags. </param>
            <param name="hTemplateFile">A handle to a template file with the GENERIC_READ access right. The template file supplies file attributes
            and extended attributes for the file that is being created. This parameter can be null</param>
            <returns>If the function succeeds, the return value is an open handle to a specified file. If a specified file exists before the function
            all and dwCreationDisposition is CREATE_ALWAYS or OPEN_ALWAYS, a call to GetLastError returns ERROR_ALREADY_EXISTS, even when the function
            succeeds. If a file does not exist before the call, GetLastError returns 0 (zero).
            If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.CreateNamedPipeW(System.String,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES*)">
            <summary>
            Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name="lpName"></param>
            <param name="dwOpenMode"></param>
            <param name="dwPipeMode"></param>
            <param name="nMaxInstances"></param>
            <param name="nOutBufferSize"></param>
            <param name="nInBufferSize"></param>
            <param name="nDefaultTimeOut"></param>
            <param name="lpSecurityAttributes"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.GetCurrentProcess">
            <summary>
            Retrieves a pseudo handle for the current process.
            </summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.GetCurrentProcessId">
            <summary>
            Retrieves the process identifier of the calling process.
            </summary>
            <returns>The return value is the process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.OpenProcess(System.UInt32,System.Int32,System.UInt32)">
            <summary>Opens an existing local process object.</summary>
            <param name="dwDesiredAccess">The access to the process object.</param>
            <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle.</param>
            <param name="dwProcessId">The identifier of the local process to be opened. If the specified process is the System Process (0x00000000), the function fails and the last error code is ERROR_INVALID_PARAMETER. If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from opening them.</param>
            <returns>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.ReadFile(System.Void*,System.Void*,System.UInt32,System.UInt32*,JetBrains.MSBuild.Logger.Infra.Util.OVERLAPPED*)">
            <summary>
            Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
            This function is designed for both synchronous and asynchronous operations. For a similar function designed solely for asynchronous operation, see ReadFileEx.
            </summary>
            <param name="hFile"></param>
            <param name="lpBuffer"></param>
            <param name="nNumberOfBytesToRead"></param>
            <param name="lpNumberOfBytesRead"></param>
            <param name="lpOverlapped"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.RegisterWaitForSingleObject(System.Void**,System.Void*,System.Void*,System.Void*,System.UInt32,System.UInt32)">
            <summary>
             Directs a wait thread in the thread pool to wait on the object. The wait thread queues the specified callback function to the thread pool when one of the following occurs:
            The specified object is in the signaled state.
            The time-out interval elapses.
            </summary>
            <param name="phNewWaitObject"></param>
            <param name="hObject"></param>
            <param name="Callback"><see cref="T:JetBrains.MSBuild.Logger.Infra.Util.WAITORTIMERCALLBACK"/></param>
            <param name="Context"></param>
            <param name="dwMilliseconds"></param>
            <param name="dwFlags"><see cref="T:JetBrains.MSBuild.Logger.Infra.Util.RegisterWaitForSingleObjectFlags"/></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.SetFileCompletionNotificationModes(System.Void*,System.Byte)">
            <summary>
            Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the specified file.
            </summary>
            <param name="FileHandle"></param>
            <param name="Flags"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.UnregisterWaitEx(System.Void*,System.Void*)">
            <summary>
            Cancels a registered wait operation issued by the RegisterWaitForSingleObject function.
            </summary>
            <param name="WaitHandle"></param>
            <param name="CompletionEvent"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Util.Kernel32Dll.WaitForSingleObject(System.Void*,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses. To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use the WaitForMultipleObjects.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES">
            <summary>
            The <see cref="T:JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES"/> structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure. Set this value to the size of the SECURITY_ATTRIBUTES structure.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a security descriptor for the object that controls the sharing of it. If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). The default security descriptor is based on the default DACL of the access token belonging to the calling process. By default, the default DACL in the access token of a process allows access only to the user represented by the access token. If other users must access the object, you can either create a security descriptor with the appropriate access, or add ACEs to the DACL that grants access to a group of users.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Util.WaitResult">
            <summary>
            Result flags for the wait functions.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.WaitResult.WAIT_ABANDONED">
            <summary>
             The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.WaitResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Util.WaitResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.LoggerMessageRecord">
            <summary>
            Logger events come from a running MSBuild in the form of these records.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Inject.LoggerMessageRecord.NodeID">
            <summary>
            From build event context.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Inject.LoggerMessageRecord.ProjectId">
            <summary>
            From build event context.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.LoggerMessageRecord.SerializationHeader">
            <summary>
            First goes the header, then the strings' UTF-16LE useful chars, in the same order as their length fields.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.ChannelWriter`1">
            <summary>
            Returned when you create the writer end of the channel.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.ChannelWriter`1.Write(`0)">
            <summary>
            Call to send the next item over the channel. Note that the item could be stored for some time before it is processed for serialization and transmission, so do not modify this object. Writer lifetime must not be terminated when you call this method.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.ChannelWriter`1.ItemSerializer">
            <summary>
            Turns item into bytes for sending. This might happen on the sender thread, not when the item is request for sending. That's why you write items in the API, not bytes, and we need a separate functor for turning items into bytes.
            </summary>
            <param name="item">The item to serialize.</param>
            <param name="buffer">In: the buffer for writing, content undefined. If to small, allocate a new one. Out: the buffer stuff has been actually written into, might be the input one. This buffer would be reused when returned, do not treat it as owned or readonly.</param>
            <param name="cbSize">Out: number of bytes in the buffer for the serialized item.</param>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.ChannelReader">
            <summary>
            Returned when you create the reader end of the channel.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.ChannelReader.ReadRemainingMessages">
            <summary>
              <para>Enforces waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely.</para>
              <para>Terminating the reader lifetime aborts reading and cancels remaining messages in case you want to break the channel no matter what happens to the other end. If you terminate the other end and want to make sure that all pending messages are read, call this method before proceeding with lifetime termination.</para>
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.ChannelReader.ReadRemainingMessagesAsync">
            <summary>
              <para>Enforces waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely.</para>
              <para>Terminating the reader lifetime aborts reading and cancels remaining messages in case you want to break the channel no matter what happens to the other end. If you terminate the other end and want to make sure that all pending messages are read, call this method before proceeding with lifetime termination.</para>
            </summary>
        </member>
        <member name="P:JetBrains.MSBuild.Logger.Channels.ChannelReader.ChannelName">
            <summary>
            Gets the channel name, as created by the reader, to be given to the writer side.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.DiskFileBasedPipeEmulationChannel">
            <summary>
            If pipes are not working and <see cref="T:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel"/> is not possible
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel">
            <summary>
            Pumps messages over a pipe between appdomains or processes.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.#ctor">
            <summary>
            Use the <see cref="F:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.Factory"/> instance.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.JetBrains#MSBuild#Logger#Channels#IPipeMessageChannel#CreateReader(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.Action{System.Byte[],System.UInt32,System.UInt32},JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Defines the channel name, opens the reader, returns the token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely.
            </summary>
            <param name="lifetime">Closes the channel and drops unread messages.</param>
            <param name="FOnRead">Callback on every message. The buffer is reusable, do not store it.</param>
            <param name="logger"></param>
            <returns>The token which allows to enforce waiting for all pending messages to be processed before closing the channel — you must be sure that the writer has disconnected in such case, otherwise you might be waiting indefinitely; and the channel name to be passed to the writer.</returns>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.JetBrains#MSBuild#Logger#Channels#IPipeMessageChannel#CreateWriter``1(JetBrains.MSBuild.Logger.Infra.Imitations.Lifetime,System.String,JetBrains.MSBuild.Logger.Channels.ChannelWriter{``0}.ItemSerializer,JetBrains.MSBuild.Logger.Infra.Imitations.ILogger)">
            <summary>
            Opens the writing end of the pipe; it's the client, so the server (reader) end must be opened already.
            </summary>
            <typeparam name="TItem">Item type, for the serializer. Serialization is taken out async, so the implementation needs the serializer to run.</typeparam>
            <param name="lifetime">Enforces writing out all remaining items and close the channel.</param>
            <param name="sChannelName">The channel name given in the <see cref="T:JetBrains.MSBuild.Logger.Channels.ChannelReader"/> struct obtained when opening the reader end.</param>
            <param name="serializer">Per-item serializer.</param>
            <param name="logger"></param>
            <returns>A token which has the write function.</returns>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.ManualResetAwaitHandle">
            <summary>
            An async wait handle which is somewhat like the manual-reset wait handle.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.ManualResetAwaitHandle.ResetAndWaitAsync">
            <summary>
            Resets the state.
            Awaits for someone to call <see cref="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.ManualResetAwaitHandle.Set"/>.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.ManualResetAwaitHandle.Set">
            <summary>
            Sets the event in the signaled state. Whoever is waiting on <see cref="M:JetBrains.MSBuild.Logger.Channels.NamedPipeMessageChannel.ManualResetAwaitHandle.ResetAndWaitAsync"/>, would wake up.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Imitations.Extensions.IsEmpty(System.String)">
            <summary>
            Checks whether the string is an empty string or a <c>Null</c> reference.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Imitations.Extensions.WithNotNull``1(``0,System.Action{``0})">
            <summary>
            Executes <paramref name="F" /> on the <paramref name="item" />, if the <paramref name="item" /> is not <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Imitations.Extensions.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Infra.Imitations.LockObject">
            <summary>
            When you need to create an instance of some object to <c>lock</c> against it (<see cref="M:System.Threading.Monitor.Enter(System.Object)"/>), use this class.
            It has an additional method for entering the lock with a timeout (throwing an exception if failed).
            </summary>
        </member>
        <member name="M:JetBrains.MSBuild.Logger.Infra.Imitations.Logger.Catch(System.String,System.Action)">
            <summary>
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Infra.Imitations.MemoryUtil.ByteBufferUnderlohSize">
            <summary>
            Specifies the maximum optimal size of the byte buffer, such as for copying, which still fits into the regular heaps and does not fall off to LOH.
            Borrowed from System.Stream v4, which also recommends to have it a multiple of 4096 (page size?.. dunno).
            </summary>
        </member>
        <member name="F:JetBrains.MSBuild.Logger.Inject.ChannelChoice.IsForwardingLoggerSupported">
            <summary>
            Whether we can use multiple per-node loggers with this channel.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.MsbuildCmdletCentralLogger">
            <summary>
              <para>MSBuild logger so that we could get error and warning messages as objects and not as just plain text which has to be parsed.</para>
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.LoggerParameterData">
            <summary>
              Params which are given to the logger object running in the remote MSBuild instance, used for opening a channel for sending build messages to the main cmdlet.
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.MsbuildCmdletLegacyLogger">
            <summary>
              <para>MSBuild logger so that we could get error and warning messages as objects and not as just plain text which has to be parsed.</para>
              <para>Unlike <see cref="T:JetBrains.MSBuild.Logger.Inject.MsbuildCmdletForwardingLogger"/> technology which makes use of local per-node loggers, this one is loaded into the central node and MSBuild uses its own marshalling to deliver messages to this node. This is used when the message channel does not support multiple writers.</para>
            </summary>
        </member>
        <member name="T:JetBrains.MSBuild.Logger.Inject.MsbuildCmdletForwardingLogger">
            <summary>
              <para>MSBuild logger so that we could get error and warning messages as objects and not as just plain text which has to be parsed.</para>
              <para>A forwarding logger copy is loaded into each MSBuild node, so the messages are streamed directly from source without being first marshaled to the central MSBuild node.</para>
            </summary>
        </member>
    </members>
</doc>
